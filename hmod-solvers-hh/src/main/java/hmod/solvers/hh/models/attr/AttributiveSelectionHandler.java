
package hmod.solvers.hh.models.attr;

import hmod.core.Condition;
import hmod.solvers.hh.models.oscillation.OscillationHandler;
import hmod.core.Statement;
import hmod.solvers.common.HeuristicOutputIds;
import hmod.solvers.common.IterationHandler;
import hmod.solvers.common.Selector;
import hmod.solvers.hh.models.selection.LLHeuristicsHandler;
import hmod.solvers.hh.models.selection.HeuristicRunnerHandler;
import hmod.solvers.hh.models.selection.LowLevelHeuristicInfo;
import hmod.solvers.hh.models.soltrack.SolutionTrackingHandler;
import hmod.solvers.hh.models.soltrack.TrackableSolutionHandler;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import optefx.util.output.OutputManager;
import optefx.util.random.RandomTool;

/**
 *
 * @author Enrique Urra C.
 */
public final class AttributiveSelectionHandler
{
    private final OscillationHandler oh;
    private final HeuristicRunnerHandler hrh;
    private final HeuristicScoringHandler hsh;
    private final TrackableSolutionHandler<HHAttributiveSolution> sh;
    private final LLHeuristicsHandler llhh;
    private final SolutionTrackingHandler sth;
    private final IterationHandler ih;

    AttributiveSelectionHandler(OscillationHandler oh, 
                                HeuristicRunnerHandler hrh, 
                                HeuristicScoringHandler hsh, 
                                TrackableSolutionHandler<HHAttributiveSolution> sh,
                                LLHeuristicsHandler llhh,
                                SolutionTrackingHandler sth,
                                IterationHandler ih)
    {
        this.oh = oh;
        this.hrh = hrh;
        this.hsh = hsh;
        this.sh = sh;
        this.llhh = llhh;
        this.sth = sth;
        this.ih = ih;
    }
    
    /*public void checkOscillationStart()
    {
        if(ih.getCurrentIteration() > ih.getMaxIteration() * soh.getLearningTime())
        {
            OutputManager.println(OutputIds.SO_EVENTS, "Starting oscillation!");
            soh.enableOscillation();
        }
    }*/
    
    public void changeToRandomHeuristic()
    {
        int count = llhh.getHeuristicsCount();
        List<Statement> toSelect = new ArrayList<>(count - 1);
        Statement currHeuristic = hrh.getHeuristicToRun();
        
        for(int i = 0; i < count; i++)
        {
            Statement h = llhh.getHeuristicAt(i);
            
            if(currHeuristic != h)
                toSelect.add(h);
        }
        
        hrh.setHeuristicToRun(toSelect.get(RandomTool.getInt(toSelect.size())));
    }
    
    /**
     * Operator related to the attributive memory model.
     * Updates the statistical information of the recently executed heuristic based
     * on the attributive information of the solution generated through it.
     */
    public void updateStatsOfCurrentHeuristic()
    {
        // The current heuristic is evaluated according to the change effect 
        // in the solution generated by it before the heuristic execution 
        // (input solution), measured on the solution after the heuristic 
        // execution (output solution). The effect (IR) is measured by the  
        // following rate:
        //      IR = 1 - (Ns / N)
        // where (Ns) is the count of attributes in the output solution that
        // are also present in the input solution, and (N) is the total count of
        // the attributes in the output solution. Therefore, (IR) measures the 
        // change impact generated by the heuristic.
        Statement currStep = hrh.getHeuristicToRun();

        // Heuristic without stats (could be the initializer)
        if(!hsh.hasScore(currStep))
            return;

        HHAttributiveSolution inputSol = sh.getInputSolution();
        HHAttributiveSolution outputSol = sh.getOutputSolution();
        AttributesCollection inputAttrs = inputSol.getAttributesCollection();
        AttributesCollection outputAttrs = outputSol.getAttributesCollection();
        
        hsh.addReadingFor(currStep, inputAttrs, outputAttrs);
        printHeuristicStatsSheet();
    }
    
    public boolean shouldChangeHeuristic()
    {
        return RandomTool.getDouble() > oh.getCurrentOscillationRate();
    }
    
    public Statement configSelectorByChangeImpact(Selector<HeuristicSelectionScore> targetSel)
    {
        return () -> {
            int heuristicsCount = llhh.getHeuristicsCount();
            //double intensifyLevel = 1 - Math.tanh(sth.getLocalNoImproveIterations() / 100.0);
            double oscillationRate = oh.getCurrentOscillationRate();

            for(int i = 0; i < heuristicsCount; i++)
            {
                Statement heuristic = llhh.getHeuristicAt(i);
                
                double thisScore = hsh.getCurrentScore(heuristic);
                double finalScore = Math.abs(thisScore - oscillationRate);
                
                /*
                if(currScore >= 0.5)
                    finalScore = currScore - intensifyLevel * (2 * currScore - 1);
                else
                    finalScore = currScore + intensifyLevel * (1 - 2 * currScore);
                */
                //finalScore = currScore + (1 - currScore) * (1 - oscillationRate);                

                targetSel.addElement(new HeuristicSelectionScore(heuristic, finalScore));
            }
        };
    }
    
    public Condition heuristicsRemainingIn(Selector<HeuristicSelectionScore> targetSel)
    {
        return () -> !targetSel.isEmpty();
    }
    
    public Statement selectHeuristicAndRemove(Selector<HeuristicSelectionScore> targetSel)
    {
        return () -> {
            HeuristicSelectionScore score = targetSel.select();
            hrh.setHeuristicToRun(score.getHeuristic());
            targetSel.removeElement(score);
        };
    }
    
    /*public void selectHeuristicByChangeImpact()
    {
        double oscillationRate = oh.getCurrentOscillationRate();
        int heuristicsCount = llhh.getHeuristicsCount();
        
        List<HeuristicSelectionScore> scores = new ArrayList<>(heuristicsCount);
        
        for(int i = 0; i < heuristicsCount; i++)
        {
            Statement heuristic = llhh.getHeuristicAt(i);
            double currScore = hsh.getCurrentScore(heuristic);
            double finalScore;
            
            if(currScore >= 0.5)
                finalScore = currScore - oscillationRate * (2 * currScore - 1);
            else
                finalScore = currScore + oscillationRate * (1 - 2 * currScore);
            
            scores.add(new HeuristicSelectionScore(heuristic, finalScore));
        }
        
        scores = scores.stream().sorted((hmod.solvers.hh.models.attr.HeuristicSelectionScore x, hmod.solvers.hh.models.attr.HeuristicSelectionScore y) -> {
                if(x.getScore() > y.getScore())
                    return -1;
                else if(x.getScore() < y.getScore())
                    return 1;
                else
                    return 0;
            }).
            collect(Collectors.toList());
        
        // By using a roulette wheel selection-scheme, an heuristic is finally
        // selected according to its final score
        RouletteSelector<HeuristicSelectionScore> rs = new RouletteSelector<>(scores, (hmod.solvers.hh.models.attr.HeuristicSelectionScore hs) -> hs.score).
            setAmplificator(amplificatorFactor);
        
        int selectedPos = rs.select();
        Statement selected = scores.get(selectedPos).getHeuristic();
        hrh.setHeuristicToRun(selected);
    }*/
    
    /**
     * Selects a heuristic based on its change impact value.
     * The selection procedure is based on the following related values:
     * - The current impact rate mean for each heuristic (IR).
     * - The current oscillation rate (a).
     * - The grow proportion (u).
     * - The current number of iterations passed since the last local 
     *   solution improvement (t').
     * - An aplification score parameter (g).
     *
     * For each heuristic, a selection score (HS) is calculated through the
     * following formula:
     * 
     *                 HS = (1 + IR * [g(t')*(1 - a)- 1]) * g
     * 
     * in where
     * 
     *        g(t') = 1 - [ (exp(pi/2) - 1) / (u * t' + exp(pi/2) - 1) ]
     * 
     * is a function that depends on the current (t') value and that moves
     * between the 0 and 1 values. When (t') is near zero (recent local 
     * improvement), g(t') also tends to zero. When (t') tends to an higher
     * value (distant local improvement), g(t') tends to 1.
     *
     * The formula allows to achieve the following effects in the current 
     * selection strategy, related to the variables used:
     * - When (a) is near 1 (intensification), the score mainly depends on 
     *   the (IR) value, giving a higher score if such value is low.
     *   Therefore, when the search is intensifying, heuristics with a low 
     *   impact tend to be selected.
     * - When (a) is near 0 (diversification), the score depends on the (t')
     *   value:
     *     * If (t') is near 0 then g(t') is near 0, producing the same 
     *       effect as (a) is near 1. This allows to prefer heuristics with 
     *       a low impact when diversifying and a local optima was recently 
     *       found, allowing to focus the search on possible new places of  
     *       the search space.
     *     * If (t') is higher then g(t') is near 1, and as (a) is near 0, 
     *       the (IR) value influence in the formula is neutralized, giving 
     *       to all heuristics a score close to 1. This allows to select the 
     *       heuristics with an approximate uniform probability when 
     *       diversifying and the local optima cannot be improved, therefore
     *       highly disruptive heuristics have good chances to be selected 
     *       in this phase of the strategy.
     */
    /*public void selectHeuristicByChangeImpact()
    {
        double oscillationRate = soh.getCurrentOscillationRate();
        double growProportion = soh.getGrowProportion();
        int localNonImprovingIterations = sth.getLocalNoImproveIterations();
        double amplificationScore = soh.getAmplificationScore();
        int heuristicsCount = llhh.getHeuristicsCount();
        //double[] heuristicsFinalScores = new double[heuristicsCount];
        //double finalScoresSum = 0.0;
        double currSubScore = 1 - ((Math.exp(Math.PI / 2.0) - 1) / (growProportion * localNonImprovingIterations + Math.exp(Math.PI / 2.0) - 1));
        List<HeuristicScore> scores = new ArrayList<>(heuristicsCount);
        
        for(int i = 0; i < heuristicsCount; i++)
        {
            Statement heuristic = llhh.getHeuristicAt(i);
            double currScore = hsh.getCurrentScore(heuristic);            
            //double currFinalScore = (1 + currScore * (currSubScore * (1 - oscillationRate) - 1)) * amplificationScore;
            double currFinalScore = 1 + currScore * (currSubScore * (1 - oscillationRate) - 1);

            //finalScoresSum += currFinalScore;
            //heuristicsFinalScores[i] = currFinalScore;
            scores.add(new HeuristicSelectionScore(heuristic, currFinalScore));
        }
        
        List<Double> orderedScores = scores.stream().sorted((x, y) -> {
                if(x.getScore() < y.getScore())
                    return -1;
                else if(x.getScore() > y.getScore())
                    return 1;
                else
                    return 0;
            }).
            map((hs) -> hs.score).
            collect(Collectors.toList());
        
        // By using a roulette wheel selection-scheme, an heuristic is finally
        // selected according to its final score
        RouletteSelector rs = new RouletteSelector(orderedScores).setAmplificator(amplificationScore);
        int selectedPos = rs.select();
        hrh.setHeuristicToRun(scores.get(selectedPos).getHeuristic());
    }*/
        
    public void printHeuristicScores()
    {
        PrintWriter pw = OutputManager.getCurrent().getOutput(HeuristicOutputIds.EXECUTION_INFO);
        
        if(pw != null)
        {
            int count = llhh.getHeuristicsCount();
            StringBuilder sb = new StringBuilder("Low-level heuristic change impact scores:");
            
            for(int i = 0; i < count; i++)
            {
                LowLevelHeuristicInfo llhInfo = llhh.getInfoAt(i);
                String name = (llhInfo == null ? "Heuristic " + i : llhInfo.getName()) + ": ";
                
                sb.append("\n").append("- ").append(name).append(
                    String.format("%.6f", hsh.getCurrentScore(llhh.getHeuristicAt(i)))
                );
            }
            
            pw.println(sb.toString());
        }
    }
    
    private long printTimeStamp = -1;
    
    public void printHeuristicStatsSheet()
    {
        PrintWriter pw = OutputManager.getCurrent().getOutput(AttributiveSelectionOutputIds.HEURISTIC_STATS_SHEET);
        
        if(pw != null && (printTimeStamp == -1 || (System.currentTimeMillis() - printTimeStamp) >= 100))
        {
            printTimeStamp = System.currentTimeMillis();
            int count = llhh.getHeuristicsCount();
            String line = "";
            
            for(int i = 0; i < count; i++)
                line += String.format("%.6f\t", hsh.getCurrentScore(llhh.getHeuristicAt(i)));
            
            pw.println(line);
        }
    }
}
